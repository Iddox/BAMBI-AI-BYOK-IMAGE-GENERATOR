"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["bambiJsonp"] = self["bambiJsonp"] || []).push([["framework-node_modules_next_dist_client_app-i"],{

/***/ "(app-pages-browser)/./node_modules/next/dist/client/app-index.js":
/*!****************************************************!*\
  !*** ./node_modules/next/dist/client/app-index.js ***!
  \****************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("/* global location */ \nvar _s = $RefreshSig$();\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"hydrate\", ({\n    enumerable: true,\n    get: function() {\n        return hydrate;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\n__webpack_require__(/*! ../build/polyfills/polyfill-module */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/polyfill-module.js\");\nconst _client = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react-dom/client */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/client.js\"));\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _client1 = __webpack_require__(/*! react-server-dom-webpack/client */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-server-dom-webpack/client.js\");\nconst _headmanagercontextsharedruntime = __webpack_require__(/*! ../shared/lib/head-manager-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/head-manager-context.shared-runtime.js\");\nconst _approutercontextsharedruntime = __webpack_require__(/*! ../shared/lib/app-router-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js\");\nconst _onrecoverableerror = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./on-recoverable-error */ \"(app-pages-browser)/./node_modules/next/dist/client/on-recoverable-error.js\"));\nconst _appcallserver = __webpack_require__(/*! ./app-call-server */ \"(app-pages-browser)/./node_modules/next/dist/client/app-call-server.js\");\nconst _isnextroutererror = __webpack_require__(/*! ./components/is-next-router-error */ \"(app-pages-browser)/./node_modules/next/dist/client/components/is-next-router-error.js\");\n// Since React doesn't call onerror for errors caught in error boundaries.\nconst origConsoleError = window.console.error;\nwindow.console.error = function() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    if ((0, _isnextroutererror.isNextRouterError)(args[0])) {\n        return;\n    }\n    origConsoleError.apply(window.console, args);\n};\nwindow.addEventListener(\"error\", (ev)=>{\n    if ((0, _isnextroutererror.isNextRouterError)(ev.error)) {\n        ev.preventDefault();\n        return;\n    }\n});\n/// <reference types=\"react-dom/experimental\" />\nconst appElement = document;\nconst getCacheKey = ()=>{\n    const { pathname, search } = location;\n    return pathname + search;\n};\nconst encoder = new TextEncoder();\nlet initialServerDataBuffer = undefined;\nlet initialServerDataWriter = undefined;\nlet initialServerDataLoaded = false;\nlet initialServerDataFlushed = false;\nlet initialFormStateData = null;\nfunction nextServerDataCallback(seg) {\n    if (seg[0] === 0) {\n        initialServerDataBuffer = [];\n    } else if (seg[0] === 1) {\n        if (!initialServerDataBuffer) throw new Error(\"Unexpected server data: missing bootstrap script.\");\n        if (initialServerDataWriter) {\n            initialServerDataWriter.enqueue(encoder.encode(seg[1]));\n        } else {\n            initialServerDataBuffer.push(seg[1]);\n        }\n    } else if (seg[0] === 2) {\n        initialFormStateData = seg[1];\n    }\n}\n// There might be race conditions between `nextServerDataRegisterWriter` and\n// `DOMContentLoaded`. The former will be called when React starts to hydrate\n// the root, the latter will be called when the DOM is fully loaded.\n// For streaming, the former is called first due to partial hydration.\n// For non-streaming, the latter can be called first.\n// Hence, we use two variables `initialServerDataLoaded` and\n// `initialServerDataFlushed` to make sure the writer will be closed and\n// `initialServerDataBuffer` will be cleared in the right time.\nfunction nextServerDataRegisterWriter(ctr) {\n    if (initialServerDataBuffer) {\n        initialServerDataBuffer.forEach((val)=>{\n            ctr.enqueue(encoder.encode(val));\n        });\n        if (initialServerDataLoaded && !initialServerDataFlushed) {\n            ctr.close();\n            initialServerDataFlushed = true;\n            initialServerDataBuffer = undefined;\n        }\n    }\n    initialServerDataWriter = ctr;\n}\n// When `DOMContentLoaded`, we can close all pending writers to finish hydration.\nconst DOMContentLoaded = function() {\n    if (initialServerDataWriter && !initialServerDataFlushed) {\n        initialServerDataWriter.close();\n        initialServerDataFlushed = true;\n        initialServerDataBuffer = undefined;\n    }\n    initialServerDataLoaded = true;\n};\n_c = DOMContentLoaded;\n// It's possible that the DOM is already loaded.\nif (document.readyState === \"loading\") {\n    document.addEventListener(\"DOMContentLoaded\", DOMContentLoaded, false);\n} else {\n    DOMContentLoaded();\n}\nconst nextServerDataLoadingGlobal = self.__next_f = self.__next_f || [];\nnextServerDataLoadingGlobal.forEach(nextServerDataCallback);\nnextServerDataLoadingGlobal.push = nextServerDataCallback;\nfunction createResponseCache() {\n    return new Map();\n}\nconst rscCache = createResponseCache();\nfunction useInitialServerResponse(cacheKey) {\n    const response = rscCache.get(cacheKey);\n    if (response) return response;\n    const readable = new ReadableStream({\n        start (controller) {\n            nextServerDataRegisterWriter(controller);\n        }\n    });\n    const newResponse = (0, _client1.createFromReadableStream)(readable, {\n        callServer: _appcallserver.callServer\n    });\n    rscCache.set(cacheKey, newResponse);\n    return newResponse;\n}\nfunction ServerRoot(param) {\n    _s();\n    let { cacheKey } = param;\n    _react.default.useEffect(()=>{\n        rscCache.delete(cacheKey);\n    });\n    const response = useInitialServerResponse(cacheKey);\n    const root = (0, _react.use)(response);\n    return root;\n}\n_s(ServerRoot, \"K9b7qXb5/x90+1mcPl2lLLR5/0A=\", false, function() {\n    return [\n        useInitialServerResponse\n    ];\n});\n_c1 = ServerRoot;\nconst StrictModeIfEnabled =  false ? 0 : _react.default.Fragment;\nfunction Root(param) {\n    let { children } = param;\n    if (false) {}\n    if (false) {}\n    return children;\n}\n_c2 = Root;\nfunction RSCComponent(props) {\n    return /*#__PURE__*/ _react.default.createElement(ServerRoot, {\n        ...props,\n        cacheKey: getCacheKey()\n    });\n}\n_c3 = RSCComponent;\nfunction hydrate() {\n    if (true) {\n        const rootLayoutMissingTagsError = self.__next_root_layout_missing_tags_error;\n        const HotReload = (__webpack_require__(/*! ./components/react-dev-overlay/hot-reloader-client */ \"(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/hot-reloader-client.js\")[\"default\"]);\n        // Don't try to hydrate if root layout is missing required tags, render error instead\n        if (rootLayoutMissingTagsError) {\n            const reactRootElement = document.createElement(\"div\");\n            document.body.appendChild(reactRootElement);\n            const reactRoot = _client.default.createRoot(reactRootElement, {\n                onRecoverableError: _onrecoverableerror.default\n            });\n            reactRoot.render(/*#__PURE__*/ _react.default.createElement(_approutercontextsharedruntime.GlobalLayoutRouterContext.Provider, {\n                value: {\n                    buildId: \"development\",\n                    tree: rootLayoutMissingTagsError.tree,\n                    changeByServerResponse: ()=>{},\n                    focusAndScrollRef: {\n                        apply: false,\n                        onlyHashChange: false,\n                        hashFragment: null,\n                        segmentPaths: []\n                    },\n                    nextUrl: null\n                }\n            }, /*#__PURE__*/ _react.default.createElement(HotReload, {\n                assetPrefix: rootLayoutMissingTagsError.assetPrefix\n            })));\n            return;\n        }\n    }\n    const reactEl = /*#__PURE__*/ _react.default.createElement(StrictModeIfEnabled, null, /*#__PURE__*/ _react.default.createElement(_headmanagercontextsharedruntime.HeadManagerContext.Provider, {\n        value: {\n            appDir: true\n        }\n    }, /*#__PURE__*/ _react.default.createElement(Root, null, /*#__PURE__*/ _react.default.createElement(RSCComponent, null))));\n    const options = {\n        onRecoverableError: _onrecoverableerror.default\n    };\n    const isError = document.documentElement.id === \"__next_error__\";\n    if (true) {\n        // Patch console.error to collect information about hydration errors\n        const patchConsoleError = (__webpack_require__(/*! ./components/react-dev-overlay/internal/helpers/hydration-error-info */ \"(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/hydration-error-info.js\").patchConsoleError);\n        if (!isError) {\n            patchConsoleError();\n        }\n    }\n    if (isError) {\n        if (true) {\n            // if an error is thrown while rendering an RSC stream, this will catch it in dev\n            // and show the error overlay\n            const ReactDevOverlay = (__webpack_require__(/*! ./components/react-dev-overlay/internal/ReactDevOverlay */ \"(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/internal/ReactDevOverlay.js\")[\"default\"]);\n            const INITIAL_OVERLAY_STATE = (__webpack_require__(/*! ./components/react-dev-overlay/internal/error-overlay-reducer */ \"(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/internal/error-overlay-reducer.js\").INITIAL_OVERLAY_STATE);\n            const getSocketUrl = (__webpack_require__(/*! ./components/react-dev-overlay/internal/helpers/get-socket-url */ \"(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/get-socket-url.js\").getSocketUrl);\n            let errorTree = /*#__PURE__*/ _react.default.createElement(ReactDevOverlay, {\n                state: INITIAL_OVERLAY_STATE,\n                onReactError: ()=>{}\n            }, reactEl);\n            const socketUrl = getSocketUrl( false || \"\");\n            const socket = new window.WebSocket(\"\" + socketUrl + \"/_next/webpack-hmr\");\n            // add minimal \"hot reload\" support for RSC errors\n            const handler = (event)=>{\n                let obj;\n                try {\n                    obj = JSON.parse(event.data);\n                } catch (e) {}\n                if (!obj || !(\"action\" in obj)) {\n                    return;\n                }\n                if (obj.action === \"serverComponentChanges\") {\n                    window.location.reload();\n                }\n            };\n            socket.addEventListener(\"message\", handler);\n            _client.default.createRoot(appElement, options).render(errorTree);\n        } else {}\n    } else {\n        _react.default.startTransition(()=>_client.default.hydrateRoot(appElement, reactEl, {\n                ...options,\n                experimental_formState: initialFormStateData\n            }));\n    }\n    // TODO-APP: Remove this logic when Float has GC built-in in development.\n    if (true) {\n        const { linkGc } = __webpack_require__(/*! ./app-link-gc */ \"(app-pages-browser)/./node_modules/next/dist/client/app-link-gc.js\");\n        linkGc();\n    }\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=app-index.js.map\nvar _c, _c1, _c2, _c3;\n$RefreshReg$(_c, \"DOMContentLoaded\");\n$RefreshReg$(_c1, \"ServerRoot\");\n$RefreshReg$(_c2, \"Root\");\n$RefreshReg$(_c3, \"RSCComponent\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2FwcC1pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxtQkFBbUIsR0FBZ0I7O0FBQ25DQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsMkNBQTBDO0lBQ3RDSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsMkJBQTJCQyxtQkFBT0EsQ0FBQyxnSUFBeUM7QUFDbEYsTUFBTUMsNEJBQTRCRCxtQkFBT0EsQ0FBQyxrSUFBMEM7QUFDcEZBLG1CQUFPQSxDQUFDLDJIQUFvQztBQUM1QyxNQUFNRSxVQUFVLFdBQVcsR0FBR0gseUJBQXlCSSxDQUFDLENBQUNILG1CQUFPQSxDQUFDLG1HQUFrQjtBQUNuRixNQUFNSSxTQUFTLFdBQVcsR0FBR0gsMEJBQTBCRSxDQUFDLENBQUNILG1CQUFPQSxDQUFDLG1GQUFPO0FBQ3hFLE1BQU1LLFdBQVdMLG1CQUFPQSxDQUFDLGlJQUFpQztBQUMxRCxNQUFNTSxtQ0FBbUNOLG1CQUFPQSxDQUFDLHlKQUFtRDtBQUNwRyxNQUFNTyxpQ0FBaUNQLG1CQUFPQSxDQUFDLHFKQUFpRDtBQUNoRyxNQUFNUSxzQkFBc0IsV0FBVyxHQUFHVCx5QkFBeUJJLENBQUMsQ0FBQ0gsbUJBQU9BLENBQUMsMkdBQXdCO0FBQ3JHLE1BQU1TLGlCQUFpQlQsbUJBQU9BLENBQUMsaUdBQW1CO0FBQ2xELE1BQU1VLHFCQUFxQlYsbUJBQU9BLENBQUMsaUlBQW1DO0FBQ3RFLDBFQUEwRTtBQUMxRSxNQUFNVyxtQkFBbUJDLE9BQU9DLE9BQU8sQ0FBQ0MsS0FBSztBQUM3Q0YsT0FBT0MsT0FBTyxDQUFDQyxLQUFLLEdBQUc7SUFDbkIsSUFBSSxJQUFJQyxPQUFPQyxVQUFVQyxNQUFNLEVBQUVDLE9BQU8sSUFBSUMsTUFBTUosT0FBT0ssT0FBTyxHQUFHQSxPQUFPTCxNQUFNSyxPQUFP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Z0JBQzVFLEdBQUdHLE9BQU87Z0JBQ1YwQix3QkFBd0J2RztZQUM1QjtJQUNSO0lBQ0EseUVBQXlFO0lBQ3pFLElBQUl1QyxJQUFxQyxFQUFFO1FBQ3ZDLE1BQU0sRUFBRWlFLE1BQU0sRUFBRSxHQUFHL0ksbUJBQU9BLENBQUMseUZBQWU7UUFDMUMrSTtJQUNKO0FBQ0o7QUFFQSxJQUFJLENBQUMsT0FBT3JKLFFBQVE4RSxPQUFPLEtBQUssY0FBZSxPQUFPOUUsUUFBUThFLE9BQU8sS0FBSyxZQUFZOUUsUUFBUThFLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBTzlFLFFBQVE4RSxPQUFPLENBQUN3RSxVQUFVLEtBQUssYUFBYTtJQUNyS3hKLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUThFLE9BQU8sRUFBRSxjQUFjO1FBQUU3RSxPQUFPO0lBQUs7SUFDbkVILE9BQU95SixNQUFNLENBQUN2SixRQUFROEUsT0FBTyxFQUFFOUU7SUFDL0J3SixPQUFPeEosT0FBTyxHQUFHQSxRQUFROEUsT0FBTztBQUNsQyxFQUVBLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9hcHAtaW5kZXguanM/ZDcwNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBnbG9iYWwgbG9jYXRpb24gKi8gXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJoeWRyYXRlXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBoeWRyYXRlO1xuICAgIH1cbn0pO1xuY29uc3QgX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0ID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9fL19pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdFwiKTtcbmNvbnN0IF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL18vX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZFwiKTtcbnJlcXVpcmUoXCIuLi9idWlsZC9wb2x5ZmlsbHMvcG9seWZpbGwtbW9kdWxlXCIpO1xuY29uc3QgX2NsaWVudCA9IC8qI19fUFVSRV9fKi8gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0Ll8ocmVxdWlyZShcInJlYWN0LWRvbS9jbGllbnRcIikpO1xuY29uc3QgX3JlYWN0ID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkLl8ocmVxdWlyZShcInJlYWN0XCIpKTtcbmNvbnN0IF9jbGllbnQxID0gcmVxdWlyZShcInJlYWN0LXNlcnZlci1kb20td2VicGFjay9jbGllbnRcIik7XG5jb25zdCBfaGVhZG1hbmFnZXJjb250ZXh0c2hhcmVkcnVudGltZSA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL2hlYWQtbWFuYWdlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lXCIpO1xuY29uc3QgX2FwcHJvdXRlcmNvbnRleHRzaGFyZWRydW50aW1lID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lXCIpO1xuY29uc3QgX29ucmVjb3ZlcmFibGVlcnJvciA9IC8qI19fUFVSRV9fKi8gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0Ll8ocmVxdWlyZShcIi4vb24tcmVjb3ZlcmFibGUtZXJyb3JcIikpO1xuY29uc3QgX2FwcGNhbGxzZXJ2ZXIgPSByZXF1aXJlKFwiLi9hcHAtY2FsbC1zZXJ2ZXJcIik7XG5jb25zdCBfaXNuZXh0cm91dGVyZXJyb3IgPSByZXF1aXJlKFwiLi9jb21wb25lbnRzL2lzLW5leHQtcm91dGVyLWVycm9yXCIpO1xuLy8gU2luY2UgUmVhY3QgZG9lc24ndCBjYWxsIG9uZXJyb3IgZm9yIGVycm9ycyBjYXVnaHQgaW4gZXJyb3IgYm91bmRhcmllcy5cbmNvbnN0IG9yaWdDb25zb2xlRXJyb3IgPSB3aW5kb3cuY29uc29sZS5lcnJvcjtcbndpbmRvdy5jb25zb2xlLmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICBpZiAoKDAsIF9pc25leHRyb3V0ZXJlcnJvci5pc05leHRSb3V0ZXJFcnJvcikoYXJnc1swXSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBvcmlnQ29uc29sZUVycm9yLmFwcGx5KHdpbmRvdy5jb25zb2xlLCBhcmdzKTtcbn07XG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIChldik9PntcbiAgICBpZiAoKDAsIF9pc25leHRyb3V0ZXJlcnJvci5pc05leHRSb3V0ZXJFcnJvcikoZXYuZXJyb3IpKSB7XG4gICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG59KTtcbi8vLyA8cmVmZXJlbmNlIHR5cGVzPVwicmVhY3QtZG9tL2V4cGVyaW1lbnRhbFwiIC8+XG5jb25zdCBhcHBFbGVtZW50ID0gZG9jdW1lbnQ7XG5jb25zdCBnZXRDYWNoZUtleSA9ICgpPT57XG4gICAgY29uc3QgeyBwYXRobmFtZSwgc2VhcmNoIH0gPSBsb2NhdGlvbjtcbiAgICByZXR1cm4gcGF0aG5hbWUgKyBzZWFyY2g7XG59O1xuY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xubGV0IGluaXRpYWxTZXJ2ZXJEYXRhQnVmZmVyID0gdW5kZWZpbmVkO1xubGV0IGluaXRpYWxTZXJ2ZXJEYXRhV3JpdGVyID0gdW5kZWZpbmVkO1xubGV0IGluaXRpYWxTZXJ2ZXJEYXRhTG9hZGVkID0gZmFsc2U7XG5sZXQgaW5pdGlhbFNlcnZlckRhdGFGbHVzaGVkID0gZmFsc2U7XG5sZXQgaW5pdGlhbEZvcm1TdGF0ZURhdGEgPSBudWxsO1xuZnVuY3Rpb24gbmV4dFNlcnZlckRhdGFDYWxsYmFjayhzZWcpIHtcbiAgICBpZiAoc2VnWzBdID09PSAwKSB7XG4gICAgICAgIGluaXRpYWxTZXJ2ZXJEYXRhQnVmZmVyID0gW107XG4gICAgfSBlbHNlIGlmIChzZWdbMF0gPT09IDEpIHtcbiAgICAgICAgaWYgKCFpbml0aWFsU2VydmVyRGF0YUJ1ZmZlcikgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBzZXJ2ZXIgZGF0YTogbWlzc2luZyBib290c3RyYXAgc2NyaXB0LlwiKTtcbiAgICAgICAgaWYgKGluaXRpYWxTZXJ2ZXJEYXRhV3JpdGVyKSB7XG4gICAgICAgICAgICBpbml0aWFsU2VydmVyRGF0YVdyaXRlci5lbnF1ZXVlKGVuY29kZXIuZW5jb2RlKHNlZ1sxXSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5pdGlhbFNlcnZlckRhdGFCdWZmZXIucHVzaChzZWdbMV0pO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChzZWdbMF0gPT09IDIpIHtcbiAgICAgICAgaW5pdGlhbEZvcm1TdGF0ZURhdGEgPSBzZWdbMV07XG4gICAgfVxufVxuLy8gVGhlcmUgbWlnaHQgYmUgcmFjZSBjb25kaXRpb25zIGJldHdlZW4gYG5leHRTZXJ2ZXJEYXRhUmVnaXN0ZXJXcml0ZXJgIGFuZFxuLy8gYERPTUNvbnRlbnRMb2FkZWRgLiBUaGUgZm9ybWVyIHdpbGwgYmUgY2FsbGVkIHdoZW4gUmVhY3Qgc3RhcnRzIHRvIGh5ZHJhdGVcbi8vIHRoZSByb290LCB0aGUgbGF0dGVyIHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIERPTSBpcyBmdWxseSBsb2FkZWQuXG4vLyBGb3Igc3RyZWFtaW5nLCB0aGUgZm9ybWVyIGlzIGNhbGxlZCBmaXJzdCBkdWUgdG8gcGFydGlhbCBoeWRyYXRpb24uXG4vLyBGb3Igbm9uLXN0cmVhbWluZywgdGhlIGxhdHRlciBjYW4gYmUgY2FsbGVkIGZpcnN0LlxuLy8gSGVuY2UsIHdlIHVzZSB0d28gdmFyaWFibGVzIGBpbml0aWFsU2VydmVyRGF0YUxvYWRlZGAgYW5kXG4vLyBgaW5pdGlhbFNlcnZlckRhdGFGbHVzaGVkYCB0byBtYWtlIHN1cmUgdGhlIHdyaXRlciB3aWxsIGJlIGNsb3NlZCBhbmRcbi8vIGBpbml0aWFsU2VydmVyRGF0YUJ1ZmZlcmAgd2lsbCBiZSBjbGVhcmVkIGluIHRoZSByaWdodCB0aW1lLlxuZnVuY3Rpb24gbmV4dFNlcnZlckRhdGFSZWdpc3RlcldyaXRlcihjdHIpIHtcbiAgICBpZiAoaW5pdGlhbFNlcnZlckRhdGFCdWZmZXIpIHtcbiAgICAgICAgaW5pdGlhbFNlcnZlckRhdGFCdWZmZXIuZm9yRWFjaCgodmFsKT0+e1xuICAgICAgICAgICAgY3RyLmVucXVldWUoZW5jb2Rlci5lbmNvZGUodmFsKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaW5pdGlhbFNlcnZlckRhdGFMb2FkZWQgJiYgIWluaXRpYWxTZXJ2ZXJEYXRhRmx1c2hlZCkge1xuICAgICAgICAgICAgY3RyLmNsb3NlKCk7XG4gICAgICAgICAgICBpbml0aWFsU2VydmVyRGF0YUZsdXNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgaW5pdGlhbFNlcnZlckRhdGFCdWZmZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5pdGlhbFNlcnZlckRhdGFXcml0ZXIgPSBjdHI7XG59XG4vLyBXaGVuIGBET01Db250ZW50TG9hZGVkYCwgd2UgY2FuIGNsb3NlIGFsbCBwZW5kaW5nIHdyaXRlcnMgdG8gZmluaXNoIGh5ZHJhdGlvbi5cbmNvbnN0IERPTUNvbnRlbnRMb2FkZWQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoaW5pdGlhbFNlcnZlckRhdGFXcml0ZXIgJiYgIWluaXRpYWxTZXJ2ZXJEYXRhRmx1c2hlZCkge1xuICAgICAgICBpbml0aWFsU2VydmVyRGF0YVdyaXRlci5jbG9zZSgpO1xuICAgICAgICBpbml0aWFsU2VydmVyRGF0YUZsdXNoZWQgPSB0cnVlO1xuICAgICAgICBpbml0aWFsU2VydmVyRGF0YUJ1ZmZlciA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaW5pdGlhbFNlcnZlckRhdGFMb2FkZWQgPSB0cnVlO1xufTtcbi8vIEl0J3MgcG9zc2libGUgdGhhdCB0aGUgRE9NIGlzIGFscmVhZHkgbG9hZGVkLlxuaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwibG9hZGluZ1wiKSB7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgRE9NQ29udGVudExvYWRlZCwgZmFsc2UpO1xufSBlbHNlIHtcbiAgICBET01Db250ZW50TG9hZGVkKCk7XG59XG5jb25zdCBuZXh0U2VydmVyRGF0YUxvYWRpbmdHbG9iYWwgPSBzZWxmLl9fbmV4dF9mID0gc2VsZi5fX25leHRfZiB8fCBbXTtcbm5leHRTZXJ2ZXJEYXRhTG9hZGluZ0dsb2JhbC5mb3JFYWNoKG5leHRTZXJ2ZXJEYXRhQ2FsbGJhY2spO1xubmV4dFNlcnZlckRhdGFMb2FkaW5nR2xvYmFsLnB1c2ggPSBuZXh0U2VydmVyRGF0YUNhbGxiYWNrO1xuZnVuY3Rpb24gY3JlYXRlUmVzcG9uc2VDYWNoZSgpIHtcbiAgICByZXR1cm4gbmV3IE1hcCgpO1xufVxuY29uc3QgcnNjQ2FjaGUgPSBjcmVhdGVSZXNwb25zZUNhY2hlKCk7XG5mdW5jdGlvbiB1c2VJbml0aWFsU2VydmVyUmVzcG9uc2UoY2FjaGVLZXkpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IHJzY0NhY2hlLmdldChjYWNoZUtleSk7XG4gICAgaWYgKHJlc3BvbnNlKSByZXR1cm4gcmVzcG9uc2U7XG4gICAgY29uc3QgcmVhZGFibGUgPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICBzdGFydCAoY29udHJvbGxlcikge1xuICAgICAgICAgICAgbmV4dFNlcnZlckRhdGFSZWdpc3RlcldyaXRlcihjb250cm9sbGVyKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IG5ld1Jlc3BvbnNlID0gKDAsIF9jbGllbnQxLmNyZWF0ZUZyb21SZWFkYWJsZVN0cmVhbSkocmVhZGFibGUsIHtcbiAgICAgICAgY2FsbFNlcnZlcjogX2FwcGNhbGxzZXJ2ZXIuY2FsbFNlcnZlclxuICAgIH0pO1xuICAgIHJzY0NhY2hlLnNldChjYWNoZUtleSwgbmV3UmVzcG9uc2UpO1xuICAgIHJldHVybiBuZXdSZXNwb25zZTtcbn1cbmZ1bmN0aW9uIFNlcnZlclJvb3QocGFyYW0pIHtcbiAgICBsZXQgeyBjYWNoZUtleSB9ID0gcGFyYW07XG4gICAgX3JlYWN0LmRlZmF1bHQudXNlRWZmZWN0KCgpPT57XG4gICAgICAgIHJzY0NhY2hlLmRlbGV0ZShjYWNoZUtleSk7XG4gICAgfSk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSB1c2VJbml0aWFsU2VydmVyUmVzcG9uc2UoY2FjaGVLZXkpO1xuICAgIGNvbnN0IHJvb3QgPSAoMCwgX3JlYWN0LnVzZSkocmVzcG9uc2UpO1xuICAgIHJldHVybiByb290O1xufVxuY29uc3QgU3RyaWN0TW9kZUlmRW5hYmxlZCA9IHByb2Nlc3MuZW52Ll9fTkVYVF9TVFJJQ1RfTU9ERV9BUFAgPyBfcmVhY3QuZGVmYXVsdC5TdHJpY3RNb2RlIDogX3JlYWN0LmRlZmF1bHQuRnJhZ21lbnQ7XG5mdW5jdGlvbiBSb290KHBhcmFtKSB7XG4gICAgbGV0IHsgY2hpbGRyZW4gfSA9IHBhcmFtO1xuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfQU5BTFlUSUNTX0lEKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgICAgICBfcmVhY3QuZGVmYXVsdC51c2VFZmZlY3QoKCk9PntcbiAgICAgICAgICAgIHJlcXVpcmUoXCIuL3BlcmZvcm1hbmNlLXJlbGF5ZXItYXBwXCIpKCk7XG4gICAgICAgIH0sIFtdKTtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9URVNUX01PREUpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgICAgIF9yZWFjdC5kZWZhdWx0LnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICAgICAgd2luZG93Ll9fTkVYVF9IWURSQVRFRCA9IHRydWU7XG4gICAgICAgICAgICBpZiAod2luZG93Ll9fTkVYVF9IWURSQVRFRF9DQikge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5fX05FWFRfSFlEUkFURURfQ0IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgW10pO1xuICAgIH1cbiAgICByZXR1cm4gY2hpbGRyZW47XG59XG5mdW5jdGlvbiBSU0NDb21wb25lbnQocHJvcHMpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFNlcnZlclJvb3QsIHtcbiAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgIGNhY2hlS2V5OiBnZXRDYWNoZUtleSgpXG4gICAgfSk7XG59XG5mdW5jdGlvbiBoeWRyYXRlKCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgY29uc3Qgcm9vdExheW91dE1pc3NpbmdUYWdzRXJyb3IgPSBzZWxmLl9fbmV4dF9yb290X2xheW91dF9taXNzaW5nX3RhZ3NfZXJyb3I7XG4gICAgICAgIGNvbnN0IEhvdFJlbG9hZCA9IHJlcXVpcmUoXCIuL2NvbXBvbmVudHMvcmVhY3QtZGV2LW92ZXJsYXkvaG90LXJlbG9hZGVyLWNsaWVudFwiKS5kZWZhdWx0O1xuICAgICAgICAvLyBEb24ndCB0cnkgdG8gaHlkcmF0ZSBpZiByb290IGxheW91dCBpcyBtaXNzaW5nIHJlcXVpcmVkIHRhZ3MsIHJlbmRlciBlcnJvciBpbnN0ZWFkXG4gICAgICAgIGlmIChyb290TGF5b3V0TWlzc2luZ1RhZ3NFcnJvcikge1xuICAgICAgICAgICAgY29uc3QgcmVhY3RSb290RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHJlYWN0Um9vdEVsZW1lbnQpO1xuICAgICAgICAgICAgY29uc3QgcmVhY3RSb290ID0gX2NsaWVudC5kZWZhdWx0LmNyZWF0ZVJvb3QocmVhY3RSb290RWxlbWVudCwge1xuICAgICAgICAgICAgICAgIG9uUmVjb3ZlcmFibGVFcnJvcjogX29ucmVjb3ZlcmFibGVlcnJvci5kZWZhdWx0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJlYWN0Um9vdC5yZW5kZXIoLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9hcHByb3V0ZXJjb250ZXh0c2hhcmVkcnVudGltZS5HbG9iYWxMYXlvdXRSb3V0ZXJDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgYnVpbGRJZDogXCJkZXZlbG9wbWVudFwiLFxuICAgICAgICAgICAgICAgICAgICB0cmVlOiByb290TGF5b3V0TWlzc2luZ1RhZ3NFcnJvci50cmVlLFxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VCeVNlcnZlclJlc3BvbnNlOiAoKT0+e30sXG4gICAgICAgICAgICAgICAgICAgIGZvY3VzQW5kU2Nyb2xsUmVmOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcHBseTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBvbmx5SGFzaENoYW5nZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNoRnJhZ21lbnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWdtZW50UGF0aHM6IFtdXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG5leHRVcmw6IG51bGxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoSG90UmVsb2FkLCB7XG4gICAgICAgICAgICAgICAgYXNzZXRQcmVmaXg6IHJvb3RMYXlvdXRNaXNzaW5nVGFnc0Vycm9yLmFzc2V0UHJlZml4XG4gICAgICAgICAgICB9KSkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlYWN0RWwgPSAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoU3RyaWN0TW9kZUlmRW5hYmxlZCwgbnVsbCwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9oZWFkbWFuYWdlcmNvbnRleHRzaGFyZWRydW50aW1lLkhlYWRNYW5hZ2VyQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgYXBwRGlyOiB0cnVlXG4gICAgICAgIH1cbiAgICB9LCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoUm9vdCwgbnVsbCwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFJTQ0NvbXBvbmVudCwgbnVsbCkpKSk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgb25SZWNvdmVyYWJsZUVycm9yOiBfb25yZWNvdmVyYWJsZWVycm9yLmRlZmF1bHRcbiAgICB9O1xuICAgIGNvbnN0IGlzRXJyb3IgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuaWQgPT09IFwiX19uZXh0X2Vycm9yX19cIjtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIC8vIFBhdGNoIGNvbnNvbGUuZXJyb3IgdG8gY29sbGVjdCBpbmZvcm1hdGlvbiBhYm91dCBoeWRyYXRpb24gZXJyb3JzXG4gICAgICAgIGNvbnN0IHBhdGNoQ29uc29sZUVycm9yID0gcmVxdWlyZShcIi4vY29tcG9uZW50cy9yZWFjdC1kZXYtb3ZlcmxheS9pbnRlcm5hbC9oZWxwZXJzL2h5ZHJhdGlvbi1lcnJvci1pbmZvXCIpLnBhdGNoQ29uc29sZUVycm9yO1xuICAgICAgICBpZiAoIWlzRXJyb3IpIHtcbiAgICAgICAgICAgIHBhdGNoQ29uc29sZUVycm9yKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzRXJyb3IpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgLy8gaWYgYW4gZXJyb3IgaXMgdGhyb3duIHdoaWxlIHJlbmRlcmluZyBhbiBSU0Mgc3RyZWFtLCB0aGlzIHdpbGwgY2F0Y2ggaXQgaW4gZGV2XG4gICAgICAgICAgICAvLyBhbmQgc2hvdyB0aGUgZXJyb3Igb3ZlcmxheVxuICAgICAgICAgICAgY29uc3QgUmVhY3REZXZPdmVybGF5ID0gcmVxdWlyZShcIi4vY29tcG9uZW50cy9yZWFjdC1kZXYtb3ZlcmxheS9pbnRlcm5hbC9SZWFjdERldk92ZXJsYXlcIikuZGVmYXVsdDtcbiAgICAgICAgICAgIGNvbnN0IElOSVRJQUxfT1ZFUkxBWV9TVEFURSA9IHJlcXVpcmUoXCIuL2NvbXBvbmVudHMvcmVhY3QtZGV2LW92ZXJsYXkvaW50ZXJuYWwvZXJyb3Itb3ZlcmxheS1yZWR1Y2VyXCIpLklOSVRJQUxfT1ZFUkxBWV9TVEFURTtcbiAgICAgICAgICAgIGNvbnN0IGdldFNvY2tldFVybCA9IHJlcXVpcmUoXCIuL2NvbXBvbmVudHMvcmVhY3QtZGV2LW92ZXJsYXkvaW50ZXJuYWwvaGVscGVycy9nZXQtc29ja2V0LXVybFwiKS5nZXRTb2NrZXRVcmw7XG4gICAgICAgICAgICBsZXQgZXJyb3JUcmVlID0gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFJlYWN0RGV2T3ZlcmxheSwge1xuICAgICAgICAgICAgICAgIHN0YXRlOiBJTklUSUFMX09WRVJMQVlfU1RBVEUsXG4gICAgICAgICAgICAgICAgb25SZWFjdEVycm9yOiAoKT0+e31cbiAgICAgICAgICAgIH0sIHJlYWN0RWwpO1xuICAgICAgICAgICAgY29uc3Qgc29ja2V0VXJsID0gZ2V0U29ja2V0VXJsKHByb2Nlc3MuZW52Ll9fTkVYVF9BU1NFVF9QUkVGSVggfHwgXCJcIik7XG4gICAgICAgICAgICBjb25zdCBzb2NrZXQgPSBuZXcgd2luZG93LldlYlNvY2tldChcIlwiICsgc29ja2V0VXJsICsgXCIvX25leHQvd2VicGFjay1obXJcIik7XG4gICAgICAgICAgICAvLyBhZGQgbWluaW1hbCBcImhvdCByZWxvYWRcIiBzdXBwb3J0IGZvciBSU0MgZXJyb3JzXG4gICAgICAgICAgICBjb25zdCBoYW5kbGVyID0gKGV2ZW50KT0+e1xuICAgICAgICAgICAgICAgIGxldCBvYmo7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgb2JqID0gSlNPTi5wYXJzZShldmVudC5kYXRhKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICAgICAgICAgIGlmICghb2JqIHx8ICEoXCJhY3Rpb25cIiBpbiBvYmopKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9iai5hY3Rpb24gPT09IFwic2VydmVyQ29tcG9uZW50Q2hhbmdlc1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGhhbmRsZXIpO1xuICAgICAgICAgICAgX2NsaWVudC5kZWZhdWx0LmNyZWF0ZVJvb3QoYXBwRWxlbWVudCwgb3B0aW9ucykucmVuZGVyKGVycm9yVHJlZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfY2xpZW50LmRlZmF1bHQuY3JlYXRlUm9vdChhcHBFbGVtZW50LCBvcHRpb25zKS5yZW5kZXIocmVhY3RFbCk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBfcmVhY3QuZGVmYXVsdC5zdGFydFRyYW5zaXRpb24oKCk9Pl9jbGllbnQuZGVmYXVsdC5oeWRyYXRlUm9vdChhcHBFbGVtZW50LCByZWFjdEVsLCB7XG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgICAgICBleHBlcmltZW50YWxfZm9ybVN0YXRlOiBpbml0aWFsRm9ybVN0YXRlRGF0YVxuICAgICAgICAgICAgfSkpO1xuICAgIH1cbiAgICAvLyBUT0RPLUFQUDogUmVtb3ZlIHRoaXMgbG9naWMgd2hlbiBGbG9hdCBoYXMgR0MgYnVpbHQtaW4gaW4gZGV2ZWxvcG1lbnQuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBjb25zdCB7IGxpbmtHYyB9ID0gcmVxdWlyZShcIi4vYXBwLWxpbmstZ2NcIik7XG4gICAgICAgIGxpbmtHYygpO1xuICAgIH1cbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBwLWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJoeWRyYXRlIiwiX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0IiwicmVxdWlyZSIsIl9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQiLCJfY2xpZW50IiwiXyIsIl9yZWFjdCIsIl9jbGllbnQxIiwiX2hlYWRtYW5hZ2VyY29udGV4dHNoYXJlZHJ1bnRpbWUiLCJfYXBwcm91dGVyY29udGV4dHNoYXJlZHJ1bnRpbWUiLCJfb25yZWNvdmVyYWJsZWVycm9yIiwiX2FwcGNhbGxzZXJ2ZXIiLCJfaXNuZXh0cm91dGVyZXJyb3IiLCJvcmlnQ29uc29sZUVycm9yIiwid2luZG93IiwiY29uc29sZSIsImVycm9yIiwiX2xlbiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImFyZ3MiLCJBcnJheSIsIl9rZXkiLCJpc05leHRSb3V0ZXJFcnJvciIsImFwcGx5IiwiYWRkRXZlbnRMaXN0ZW5lciIsImV2IiwicHJldmVudERlZmF1bHQiLCJhcHBFbGVtZW50IiwiZG9jdW1lbnQiLCJnZXRDYWNoZUtleSIsInBhdGhuYW1lIiwic2VhcmNoIiwibG9jYXRpb24iLCJlbmNvZGVyIiwiVGV4dEVuY29kZXIiLCJpbml0aWFsU2VydmVyRGF0YUJ1ZmZlciIsInVuZGVmaW5lZCIsImluaXRpYWxTZXJ2ZXJEYXRhV3JpdGVyIiwiaW5pdGlhbFNlcnZlckRhdGFMb2FkZWQiLCJpbml0aWFsU2VydmVyRGF0YUZsdXNoZWQiLCJpbml0aWFsRm9ybVN0YXRlRGF0YSIsIm5leHRTZXJ2ZXJEYXRhQ2FsbGJhY2siLCJzZWciLCJFcnJvciIsImVucXVldWUiLCJlbmNvZGUiLCJwdXNoIiwibmV4dFNlcnZlckRhdGFSZWdpc3RlcldyaXRlciIsImN0ciIsImZvckVhY2giLCJ2YWwiLCJjbG9zZSIsIkRPTUNvbnRlbnRMb2FkZWQiLCJyZWFkeVN0YXRlIiwibmV4dFNlcnZlckRhdGFMb2FkaW5nR2xvYmFsIiwic2VsZiIsIl9fbmV4dF9mIiwiY3JlYXRlUmVzcG9uc2VDYWNoZSIsIk1hcCIsInJzY0NhY2hlIiwidXNlSW5pdGlhbFNlcnZlclJlc3BvbnNlIiwiY2FjaGVLZXkiLCJyZXNwb25zZSIsInJlYWRhYmxlIiwiUmVhZGFibGVTdHJlYW0iLCJzdGFydCIsImNvbnRyb2xsZXIiLCJuZXdSZXNwb25zZSIsImNyZWF0ZUZyb21SZWFkYWJsZVN0cmVhbSIsImNhbGxTZXJ2ZXIiLCJzZXQiLCJTZXJ2ZXJSb290IiwicGFyYW0iLCJkZWZhdWx0IiwidXNlRWZmZWN0IiwiZGVsZXRlIiwicm9vdCIsInVzZSIsIlN0cmljdE1vZGVJZkVuYWJsZWQiLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX1NUUklDVF9NT0RFX0FQUCIsIlN0cmljdE1vZGUiLCJGcmFnbWVudCIsIlJvb3QiLCJjaGlsZHJlbiIsIl9fTkVYVF9BTkFMWVRJQ1NfSUQiLCJfX05FWFRfVEVTVF9NT0RFIiwiX19ORVhUX0hZRFJBVEVEIiwiX19ORVhUX0hZRFJBVEVEX0NCIiwiUlNDQ29tcG9uZW50IiwicHJvcHMiLCJjcmVhdGVFbGVtZW50Iiwicm9vdExheW91dE1pc3NpbmdUYWdzRXJyb3IiLCJfX25leHRfcm9vdF9sYXlvdXRfbWlzc2luZ190YWdzX2Vycm9yIiwiSG90UmVsb2FkIiwicmVhY3RSb290RWxlbWVudCIsImJvZHkiLCJhcHBlbmRDaGlsZCIsInJlYWN0Um9vdCIsImNyZWF0ZVJvb3QiLCJvblJlY292ZXJhYmxlRXJyb3IiLCJyZW5kZXIiLCJHbG9iYWxMYXlvdXRSb3V0ZXJDb250ZXh0IiwiUHJvdmlkZXIiLCJidWlsZElkIiwidHJlZSIsImNoYW5nZUJ5U2VydmVyUmVzcG9uc2UiLCJmb2N1c0FuZFNjcm9sbFJlZiIsIm9ubHlIYXNoQ2hhbmdlIiwiaGFzaEZyYWdtZW50Iiwic2VnbWVudFBhdGhzIiwibmV4dFVybCIsImFzc2V0UHJlZml4IiwicmVhY3RFbCIsIkhlYWRNYW5hZ2VyQ29udGV4dCIsImFwcERpciIsIm9wdGlvbnMiLCJpc0Vycm9yIiwiZG9jdW1lbnRFbGVtZW50IiwiaWQiLCJwYXRjaENvbnNvbGVFcnJvciIsIlJlYWN0RGV2T3ZlcmxheSIsIklOSVRJQUxfT1ZFUkxBWV9TVEFURSIsImdldFNvY2tldFVybCIsImVycm9yVHJlZSIsInN0YXRlIiwib25SZWFjdEVycm9yIiwic29ja2V0VXJsIiwiX19ORVhUX0FTU0VUX1BSRUZJWCIsInNvY2tldCIsIldlYlNvY2tldCIsImhhbmRsZXIiLCJldmVudCIsIm9iaiIsIkpTT04iLCJwYXJzZSIsImRhdGEiLCJlIiwiYWN0aW9uIiwicmVsb2FkIiwic3RhcnRUcmFuc2l0aW9uIiwiaHlkcmF0ZVJvb3QiLCJleHBlcmltZW50YWxfZm9ybVN0YXRlIiwibGlua0djIiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/app-index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/app-link-gc.js":
/*!******************************************************!*\
  !*** ./node_modules/next/dist/client/app-link-gc.js ***!
  \******************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"linkGc\", ({\n    enumerable: true,\n    get: function() {\n        return linkGc;\n    }\n}));\nfunction linkGc() {\n    // TODO-APP: Remove this logic when Float has GC built-in in development.\n    if (true) {\n        const callback = (mutationList)=>{\n            for (const mutation of mutationList){\n                if (mutation.type === \"childList\") {\n                    for (const node of mutation.addedNodes){\n                        if (\"tagName\" in node && node.tagName === \"LINK\") {\n                            var _link_dataset_precedence;\n                            const link = node;\n                            if ((_link_dataset_precedence = link.dataset.precedence) == null ? void 0 : _link_dataset_precedence.startsWith(\"next\")) {\n                                const href = link.getAttribute(\"href\");\n                                if (href) {\n                                    const [resource, version] = href.split(\"?v=\");\n                                    if (version) {\n                                        const currentOrigin = window.location.origin;\n                                        const allLinks = [\n                                            ...document.querySelectorAll('link[href^=\"' + resource + '\"]'),\n                                            // It's possible that the resource is a full URL or only pathname,\n                                            // so we need to remove the alternative href as well.\n                                            ...document.querySelectorAll('link[href^=\"' + (resource.startsWith(currentOrigin) ? resource.slice(currentOrigin.length) : currentOrigin + resource) + '\"]')\n                                        ];\n                                        for (const otherLink of allLinks){\n                                            var _otherLink_dataset_precedence;\n                                            if ((_otherLink_dataset_precedence = otherLink.dataset.precedence) == null ? void 0 : _otherLink_dataset_precedence.startsWith(\"next\")) {\n                                                const otherHref = otherLink.getAttribute(\"href\");\n                                                if (otherHref) {\n                                                    const [, otherVersion] = otherHref.split(\"?v=\");\n                                                    if (!otherVersion || +otherVersion < +version) {\n                                                        // Delay the removal of the stylesheet to avoid FOUC\n                                                        // caused by `@font-face` rules, as they seem to be\n                                                        // a couple of ticks delayed between the old and new\n                                                        // styles being swapped even if the font is cached.\n                                                        setTimeout(()=>{\n                                                            otherLink.remove();\n                                                        }, 5);\n                                                        const preloadLink = document.querySelector('link[rel=\"preload\"][as=\"style\"][href=\"' + otherHref + '\"]');\n                                                        if (preloadLink) {\n                                                            preloadLink.remove();\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        };\n        // Create an observer instance linked to the callback function\n        const observer = new MutationObserver(callback);\n        observer.observe(document.head, {\n            childList: true\n        });\n    }\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=app-link-gc.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2FwcC1saW5rLWdjLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGSCwwQ0FBeUM7SUFDckNJLFlBQVk7SUFDWkMsS0FBSztRQUNELE9BQU9DO0lBQ1g7QUFDSixDQUFDLEVBQUM7QUFDRixTQUFTQTtJQUNMLHlFQUF5RTtJQUN6RSxJQUFJQyxJQUFxQyxFQUFFO1FBQ3ZDLE1BQU1DLFdBQVcsQ0FBQ0M7WUFDZCxLQUFLLE1BQU1DLFlBQVlELGFBQWE7Z0JBQ2hDLElBQUlDLFNBQVNDLElBQUksS0FBSyxhQUFhO29CQUMvQixLQUFLLE1BQU1DLFFBQVFGLFNBQVNHLFVBQVUsQ0FBQzt3QkFDbkMsSUFBSSxhQUFhRCxRQUFRQSxLQUFLRSxPQUFPLEtBQUssUUFBUTs0QkFDOUMsSUFBSUM7NEJBQ0osTUFBTUMsT0FBT0o7NEJBQ2IsSUFBSSxDQUFDRywyQkFBMkJDLEtBQUtDLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLE9BQU8sS0FBSyxJQUFJSCx5QkFBeUJJLFVBQVUsQ0FBQyxTQUFTO2dDQUNySCxNQUFNQyxPQUFPSixLQUFLSyxZQUFZLENBQUM7Z0NBQy9CLElBQUlELE1BQU07b0NBQ04sTUFBTSxDQUFDRSxVQUFVQyxRQUFRLEdBQUdILEtBQUtJLEtBQUssQ0FBQztvQ0FDdkMsSUFBSUQsU0FBUzt3Q0FDVCxNQUFNRSxnQkFBZ0JDLE9BQU9DLFFBQVEsQ0FBQ0MsTUFBTTt3Q0FDNUMsTUFBTUMsV0FBVzsrQ0FDVkMsU0FBU0MsZ0JBQWdCLENBQUMsaUJBQWlCVCxXQUFXOzRDQUN6RCxrRUFBa0U7NENBQ2xFLHFEQUFxRDsrQ0FDbERRLFNBQVNDLGdCQUFnQixDQUFDLGlCQUFrQlQsQ0FBQUEsU0FBU0gsVUFBVSxDQUFDTSxpQkFBaUJILFNBQVNVLEtBQUssQ0FBQ1AsY0FBY1EsTUFBTSxJQUFJUixnQkFBZ0JILFFBQU8sSUFBSzt5Q0FDMUo7d0NBQ0QsS0FBSyxNQUFNWSxhQUFhTCxTQUFTOzRDQUM3QixJQUFJTTs0Q0FDSixJQUFJLENBQUNBLGdDQUFnQ0QsVUFBVWpCLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLE9BQU8sS0FBSyxJQUFJaUIsOEJBQThCaEIsVUFBVSxDQUFDLFNBQVM7Z0RBQ3BJLE1BQU1pQixZQUFZRixVQUFVYixZQUFZLENBQUM7Z0RBQ3pDLElBQUllLFdBQVc7b0RBQ1gsTUFBTSxHQUFHQyxhQUFhLEdBQUdELFVBQVVaLEtBQUssQ0FBQztvREFDekMsSUFBSSxDQUFDYSxnQkFBZ0IsQ0FBQ0EsZUFBZSxDQUFDZCxTQUFTO3dEQUMzQyxvREFBb0Q7d0RBQ3BELG1EQUFtRDt3REFDbkQsb0RBQW9EO3dEQUNwRCxtREFBbUQ7d0RBQ25EZSxXQUFXOzREQUNQSixVQUFVSyxNQUFNO3dEQUNwQixHQUFHO3dEQUNILE1BQU1DLGNBQWNWLFNBQVNXLGFBQWEsQ0FBQywyQ0FBMkNMLFlBQVk7d0RBQ2xHLElBQUlJLGFBQWE7NERBQ2JBLFlBQVlELE1BQU07d0RBQ3RCO29EQUNKO2dEQUNKOzRDQUNKO3dDQUNKO29DQUNKO2dDQUNKOzRCQUNKO3dCQUNKO29CQUNKO2dCQUNKO1lBQ0o7UUFDSjtRQUNBLDhEQUE4RDtRQUM5RCxNQUFNRyxXQUFXLElBQUlDLGlCQUFpQm5DO1FBQ3RDa0MsU0FBU0UsT0FBTyxDQUFDZCxTQUFTZSxJQUFJLEVBQUU7WUFDNUJDLFdBQVc7UUFDZjtJQUNKO0FBQ0o7QUFFQSxJQUFJLENBQUMsT0FBTzVDLFFBQVE2QyxPQUFPLEtBQUssY0FBZSxPQUFPN0MsUUFBUTZDLE9BQU8sS0FBSyxZQUFZN0MsUUFBUTZDLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBTzdDLFFBQVE2QyxPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLaEQsT0FBT0MsY0FBYyxDQUFDQyxRQUFRNkMsT0FBTyxFQUFFLGNBQWM7UUFBRTVDLE9BQU87SUFBSztJQUNuRUgsT0FBT2lELE1BQU0sQ0FBQy9DLFFBQVE2QyxPQUFPLEVBQUU3QztJQUMvQmdELE9BQU9oRCxPQUFPLEdBQUdBLFFBQVE2QyxPQUFPO0FBQ2xDLEVBRUEsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2FwcC1saW5rLWdjLmpzPzkwNDMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJsaW5rR2NcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGxpbmtHYztcbiAgICB9XG59KTtcbmZ1bmN0aW9uIGxpbmtHYygpIHtcbiAgICAvLyBUT0RPLUFQUDogUmVtb3ZlIHRoaXMgbG9naWMgd2hlbiBGbG9hdCBoYXMgR0MgYnVpbHQtaW4gaW4gZGV2ZWxvcG1lbnQuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBjb25zdCBjYWxsYmFjayA9IChtdXRhdGlvbkxpc3QpPT57XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG11dGF0aW9uIG9mIG11dGF0aW9uTGlzdCl7XG4gICAgICAgICAgICAgICAgaWYgKG11dGF0aW9uLnR5cGUgPT09IFwiY2hpbGRMaXN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIG11dGF0aW9uLmFkZGVkTm9kZXMpe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwidGFnTmFtZVwiIGluIG5vZGUgJiYgbm9kZS50YWdOYW1lID09PSBcIkxJTktcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfbGlua19kYXRhc2V0X3ByZWNlZGVuY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGluayA9IG5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChfbGlua19kYXRhc2V0X3ByZWNlZGVuY2UgPSBsaW5rLmRhdGFzZXQucHJlY2VkZW5jZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9saW5rX2RhdGFzZXRfcHJlY2VkZW5jZS5zdGFydHNXaXRoKFwibmV4dFwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBocmVmID0gbGluay5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaHJlZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgW3Jlc291cmNlLCB2ZXJzaW9uXSA9IGhyZWYuc3BsaXQoXCI/dj1cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmVyc2lvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRPcmlnaW4gPSB3aW5kb3cubG9jYXRpb24ub3JpZ2luO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFsbExpbmtzID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdsaW5rW2hyZWZePVwiJyArIHJlc291cmNlICsgJ1wiXScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJdCdzIHBvc3NpYmxlIHRoYXQgdGhlIHJlc291cmNlIGlzIGEgZnVsbCBVUkwgb3Igb25seSBwYXRobmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc28gd2UgbmVlZCB0byByZW1vdmUgdGhlIGFsdGVybmF0aXZlIGhyZWYgYXMgd2VsbC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnbGlua1tocmVmXj1cIicgKyAocmVzb3VyY2Uuc3RhcnRzV2l0aChjdXJyZW50T3JpZ2luKSA/IHJlc291cmNlLnNsaWNlKGN1cnJlbnRPcmlnaW4ubGVuZ3RoKSA6IGN1cnJlbnRPcmlnaW4gKyByZXNvdXJjZSkgKyAnXCJdJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgb3RoZXJMaW5rIG9mIGFsbExpbmtzKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9vdGhlckxpbmtfZGF0YXNldF9wcmVjZWRlbmNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKF9vdGhlckxpbmtfZGF0YXNldF9wcmVjZWRlbmNlID0gb3RoZXJMaW5rLmRhdGFzZXQucHJlY2VkZW5jZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9vdGhlckxpbmtfZGF0YXNldF9wcmVjZWRlbmNlLnN0YXJ0c1dpdGgoXCJuZXh0XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvdGhlckhyZWYgPSBvdGhlckxpbmsuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdGhlckhyZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBbLCBvdGhlclZlcnNpb25dID0gb3RoZXJIcmVmLnNwbGl0KFwiP3Y9XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb3RoZXJWZXJzaW9uIHx8ICtvdGhlclZlcnNpb24gPCArdmVyc2lvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEZWxheSB0aGUgcmVtb3ZhbCBvZiB0aGUgc3R5bGVzaGVldCB0byBhdm9pZCBGT1VDXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhdXNlZCBieSBgQGZvbnQtZmFjZWAgcnVsZXMsIGFzIHRoZXkgc2VlbSB0byBiZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhIGNvdXBsZSBvZiB0aWNrcyBkZWxheWVkIGJldHdlZW4gdGhlIG9sZCBhbmQgbmV3XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0eWxlcyBiZWluZyBzd2FwcGVkIGV2ZW4gaWYgdGhlIGZvbnQgaXMgY2FjaGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdGhlckxpbmsucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIDUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmVsb2FkTGluayA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2xpbmtbcmVsPVwicHJlbG9hZFwiXVthcz1cInN0eWxlXCJdW2hyZWY9XCInICsgb3RoZXJIcmVmICsgJ1wiXScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJlbG9hZExpbmspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZWxvYWRMaW5rLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBDcmVhdGUgYW4gb2JzZXJ2ZXIgaW5zdGFuY2UgbGlua2VkIHRvIHRoZSBjYWxsYmFjayBmdW5jdGlvblxuICAgICAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGNhbGxiYWNrKTtcbiAgICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShkb2N1bWVudC5oZWFkLCB7XG4gICAgICAgICAgICBjaGlsZExpc3Q6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcHAtbGluay1nYy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwibGlua0djIiwicHJvY2VzcyIsImNhbGxiYWNrIiwibXV0YXRpb25MaXN0IiwibXV0YXRpb24iLCJ0eXBlIiwibm9kZSIsImFkZGVkTm9kZXMiLCJ0YWdOYW1lIiwiX2xpbmtfZGF0YXNldF9wcmVjZWRlbmNlIiwibGluayIsImRhdGFzZXQiLCJwcmVjZWRlbmNlIiwic3RhcnRzV2l0aCIsImhyZWYiLCJnZXRBdHRyaWJ1dGUiLCJyZXNvdXJjZSIsInZlcnNpb24iLCJzcGxpdCIsImN1cnJlbnRPcmlnaW4iLCJ3aW5kb3ciLCJsb2NhdGlvbiIsIm9yaWdpbiIsImFsbExpbmtzIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yQWxsIiwic2xpY2UiLCJsZW5ndGgiLCJvdGhlckxpbmsiLCJfb3RoZXJMaW5rX2RhdGFzZXRfcHJlY2VkZW5jZSIsIm90aGVySHJlZiIsIm90aGVyVmVyc2lvbiIsInNldFRpbWVvdXQiLCJyZW1vdmUiLCJwcmVsb2FkTGluayIsInF1ZXJ5U2VsZWN0b3IiLCJvYnNlcnZlciIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJvYnNlcnZlIiwiaGVhZCIsImNoaWxkTGlzdCIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/app-link-gc.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/app-next-dev.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/client/app-next-dev.js ***!
  \*******************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("// TODO-APP: hydration warning\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst _appbootstrap = __webpack_require__(/*! ./app-bootstrap */ \"(app-pages-browser)/./node_modules/next/dist/client/app-bootstrap.js\");\n(0, _appbootstrap.appBootstrap)(()=>{\n    __webpack_require__(/*! ./app-webpack */ \"(app-pages-browser)/./node_modules/next/dist/client/app-webpack.js\");\n    const { hydrate } = __webpack_require__(/*! ./app-index */ \"(app-pages-browser)/./node_modules/next/dist/client/app-index.js\");\n    hydrate();\n}) // TODO-APP: build indicator\n;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=app-next-dev.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2FwcC1uZXh0LWRldi5qcyIsIm1hcHBpbmdzIjoiQUFBQSw4QkFBOEI7QUFDakI7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsZ0JBQWdCQyxtQkFBT0EsQ0FBQyw2RkFBaUI7QUFDOUMsSUFBR0QsY0FBY0UsWUFBWSxFQUFFO0lBQzVCRCxtQkFBT0EsQ0FBQyx5RkFBZTtJQUN2QixNQUFNLEVBQUVFLE9BQU8sRUFBRSxHQUFHRixtQkFBT0EsQ0FBQyxxRkFBYTtJQUN6Q0U7QUFDSixHQUFHLDRCQUE0Qjs7QUFHL0IsSUFBSSxDQUFDLE9BQU9MLFFBQVFNLE9BQU8sS0FBSyxjQUFlLE9BQU9OLFFBQVFNLE9BQU8sS0FBSyxZQUFZTixRQUFRTSxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9OLFFBQVFNLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcktULE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUU0sT0FBTyxFQUFFLGNBQWM7UUFBRUwsT0FBTztJQUFLO0lBQ25FSCxPQUFPVSxNQUFNLENBQUNSLFFBQVFNLE9BQU8sRUFBRU47SUFDL0JTLE9BQU9ULE9BQU8sR0FBR0EsUUFBUU0sT0FBTztBQUNsQyxFQUVBLHdDQUF3QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9hcHAtbmV4dC1kZXYuanM/MWM1OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUT0RPLUFQUDogaHlkcmF0aW9uIHdhcm5pbmdcblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuY29uc3QgX2FwcGJvb3RzdHJhcCA9IHJlcXVpcmUoXCIuL2FwcC1ib290c3RyYXBcIik7XG4oMCwgX2FwcGJvb3RzdHJhcC5hcHBCb290c3RyYXApKCgpPT57XG4gICAgcmVxdWlyZShcIi4vYXBwLXdlYnBhY2tcIik7XG4gICAgY29uc3QgeyBoeWRyYXRlIH0gPSByZXF1aXJlKFwiLi9hcHAtaW5kZXhcIik7XG4gICAgaHlkcmF0ZSgpO1xufSkgLy8gVE9ETy1BUFA6IGJ1aWxkIGluZGljYXRvclxuO1xuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcHAtbmV4dC1kZXYuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiX2FwcGJvb3RzdHJhcCIsInJlcXVpcmUiLCJhcHBCb290c3RyYXAiLCJoeWRyYXRlIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/app-next-dev.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/app-webpack.js":
/*!******************************************************!*\
  !*** ./node_modules/next/dist/client/app-webpack.js ***!
  \******************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("// Override chunk URL mapping in the webpack runtime\n// https://github.com/webpack/webpack/blob/2738eebc7880835d88c727d364ad37f3ec557593/lib/RuntimeGlobals.js#L204\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst _deploymentid = __webpack_require__(/*! ../build/deployment-id */ \"(app-pages-browser)/./node_modules/next/dist/build/deployment-id.js\");\n// If we have a deployment ID, we need to append it to the webpack chunk names\n// I am keeping the process check explicit so this can be statically optimized\nif (false) {} else {\n    // eslint-disable-next-line no-undef\n    const getChunkScriptFilename = __webpack_require__.u;\n    // eslint-disable-next-line no-undef\n    __webpack_require__.u = function() // filename path.\n    {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        return encodeURI(getChunkScriptFilename(...args));\n    };\n// We don't need to override __webpack_require__.k because we don't modify\n// the css chunk name when not using deployment id suffixes\n// WE don't need to override __webpack_require__.miniCssF because we don't modify\n// the mini css chunk name when not using deployment id suffixes\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=app-webpack.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2FwcC13ZWJwYWNrLmpzIiwibWFwcGluZ3MiOiJBQUFBLG9EQUFvRDtBQUNwRCw4R0FBOEc7QUFDakc7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsZ0JBQWdCQyxtQkFBT0EsQ0FBQyxtR0FBd0I7QUFDdEQsOEVBQThFO0FBQzlFLDhFQUE4RTtBQUM5RSxJQUFJQyxLQUE4QixFQUFFLEVBK0JuQyxNQUFNO0lBQ0gsb0NBQW9DO0lBQ3BDLE1BQU1LLHlCQUF5QkMsbUJBQW1CQSxDQUFDQyxDQUFDO0lBQ3BELG9DQUFvQztJQUNwQ0QsbUJBQW1CQSxDQUFDQyxDQUFDLEdBQUcsV0FDeEIsaUJBQWlCOztRQUViLElBQUksSUFBSUMsT0FBT0MsVUFBVUMsTUFBTSxFQUFFQyxPQUFPLElBQUlDLE1BQU1KLE9BQU9LLE9BQU8sR0FBR0EsT0FBT0wsTUFBTUssT0FBTztZQUNuRkYsSUFBSSxDQUFDRSxLQUFLLEdBQUdKLFNBQVMsQ0FBQ0ksS0FBSztRQUNoQztRQUNBLE9BQU9DLFVBQVVULDBCQUEwQk07SUFDL0M7QUFDSiwwRUFBMEU7QUFDMUUsMkRBQTJEO0FBQzNELGlGQUFpRjtBQUNqRixnRUFBZ0U7QUFDaEU7QUFFQSxJQUFJLENBQUMsT0FBT2YsUUFBUXVCLE9BQU8sS0FBSyxjQUFlLE9BQU92QixRQUFRdUIsT0FBTyxLQUFLLFlBQVl2QixRQUFRdUIsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPdkIsUUFBUXVCLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcksxQixPQUFPQyxjQUFjLENBQUNDLFFBQVF1QixPQUFPLEVBQUUsY0FBYztRQUFFdEIsT0FBTztJQUFLO0lBQ25FSCxPQUFPMkIsTUFBTSxDQUFDekIsUUFBUXVCLE9BQU8sRUFBRXZCO0lBQy9CMEIsT0FBTzFCLE9BQU8sR0FBR0EsUUFBUXVCLE9BQU87QUFDbEMsRUFFQSx1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvYXBwLXdlYnBhY2suanM/YjYxZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBPdmVycmlkZSBjaHVuayBVUkwgbWFwcGluZyBpbiB0aGUgd2VicGFjayBydW50aW1lXG4vLyBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay93ZWJwYWNrL2Jsb2IvMjczOGVlYmM3ODgwODM1ZDg4YzcyN2QzNjRhZDM3ZjNlYzU1NzU5My9saWIvUnVudGltZUdsb2JhbHMuanMjTDIwNFxuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5jb25zdCBfZGVwbG95bWVudGlkID0gcmVxdWlyZShcIi4uL2J1aWxkL2RlcGxveW1lbnQtaWRcIik7XG4vLyBJZiB3ZSBoYXZlIGEgZGVwbG95bWVudCBJRCwgd2UgbmVlZCB0byBhcHBlbmQgaXQgdG8gdGhlIHdlYnBhY2sgY2h1bmsgbmFtZXNcbi8vIEkgYW0ga2VlcGluZyB0aGUgcHJvY2VzcyBjaGVjayBleHBsaWNpdCBzbyB0aGlzIGNhbiBiZSBzdGF0aWNhbGx5IG9wdGltaXplZFxuaWYgKHByb2Nlc3MuZW52Lk5FWFRfREVQTE9ZTUVOVF9JRCkge1xuICAgIGNvbnN0IHN1ZmZpeCA9ICgwLCBfZGVwbG95bWVudGlkLmdldERlcGxveW1lbnRJZFF1ZXJ5T3JFbXB0eVN0cmluZykoKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICBjb25zdCBnZXRDaHVua1NjcmlwdEZpbGVuYW1lID0gX193ZWJwYWNrX3JlcXVpcmVfXy51O1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgIF9fd2VicGFja19yZXF1aXJlX18udSA9IGZ1bmN0aW9uKCkgLy8gV2UgZW5vZGUgdGhlIGNodW5rIGZpbGVuYW1lIGJlY2F1c2Ugb3VyIHN0YXRpYyBzZXJ2ZXIgbWF0Y2hlcyBhZ2FpbnN0IGFuZCBlbmNvZGVkXG4gICAgLy8gZmlsZW5hbWUgcGF0aC5cbiAgICB7XG4gICAgICAgIGZvcih2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKXtcbiAgICAgICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVuY29kZVVSSShnZXRDaHVua1NjcmlwdEZpbGVuYW1lKC4uLmFyZ3MpICsgc3VmZml4KTtcbiAgICB9O1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgIGNvbnN0IGdldENodW5rQ3NzRmlsZW5hbWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLms7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICAgX193ZWJwYWNrX3JlcXVpcmVfXy5rID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvcih2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKXtcbiAgICAgICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdldENodW5rQ3NzRmlsZW5hbWUoLi4uYXJncykgKyBzdWZmaXg7XG4gICAgfTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICBjb25zdCBnZXRNaW5pQ3NzRmlsZW5hbWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLm1pbmlDc3NGO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgIF9fd2VicGFja19yZXF1aXJlX18ubWluaUNzc0YgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2V0TWluaUNzc0ZpbGVuYW1lKC4uLmFyZ3MpICsgc3VmZml4O1xuICAgIH07XG59IGVsc2Uge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgIGNvbnN0IGdldENodW5rU2NyaXB0RmlsZW5hbWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLnU7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICAgX193ZWJwYWNrX3JlcXVpcmVfXy51ID0gZnVuY3Rpb24oKSAvLyBXZSBlbm9kZSB0aGUgY2h1bmsgZmlsZW5hbWUgYmVjYXVzZSBvdXIgc3RhdGljIHNlcnZlciBtYXRjaGVzIGFnYWluc3QgYW5kIGVuY29kZWRcbiAgICAvLyBmaWxlbmFtZSBwYXRoLlxuICAgIHtcbiAgICAgICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW5jb2RlVVJJKGdldENodW5rU2NyaXB0RmlsZW5hbWUoLi4uYXJncykpO1xuICAgIH07XG4vLyBXZSBkb24ndCBuZWVkIHRvIG92ZXJyaWRlIF9fd2VicGFja19yZXF1aXJlX18uayBiZWNhdXNlIHdlIGRvbid0IG1vZGlmeVxuLy8gdGhlIGNzcyBjaHVuayBuYW1lIHdoZW4gbm90IHVzaW5nIGRlcGxveW1lbnQgaWQgc3VmZml4ZXNcbi8vIFdFIGRvbid0IG5lZWQgdG8gb3ZlcnJpZGUgX193ZWJwYWNrX3JlcXVpcmVfXy5taW5pQ3NzRiBiZWNhdXNlIHdlIGRvbid0IG1vZGlmeVxuLy8gdGhlIG1pbmkgY3NzIGNodW5rIG5hbWUgd2hlbiBub3QgdXNpbmcgZGVwbG95bWVudCBpZCBzdWZmaXhlc1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcHAtd2VicGFjay5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJfZGVwbG95bWVudGlkIiwicmVxdWlyZSIsInByb2Nlc3MiLCJlbnYiLCJORVhUX0RFUExPWU1FTlRfSUQiLCJzdWZmaXgiLCJnZXREZXBsb3ltZW50SWRRdWVyeU9yRW1wdHlTdHJpbmciLCJnZXRDaHVua1NjcmlwdEZpbGVuYW1lIiwiX193ZWJwYWNrX3JlcXVpcmVfXyIsInUiLCJfbGVuIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiYXJncyIsIkFycmF5IiwiX2tleSIsImVuY29kZVVSSSIsImdldENodW5rQ3NzRmlsZW5hbWUiLCJrIiwiZ2V0TWluaUNzc0ZpbGVuYW1lIiwibWluaUNzc0YiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/app-webpack.js\n"));

/***/ })

}]);